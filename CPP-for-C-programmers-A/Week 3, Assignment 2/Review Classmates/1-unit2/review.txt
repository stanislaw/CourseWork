Hello Yilun,

Here are my comments and advices on your work:

1) In my homework I also created separate class GraphBuilder which encapsulates the procedure of building a graph. My Graph is just a plain graph class - it knows nothing about probabilities - so I find my Graph class much easier to read than yours. For example addEdge method merely adds edge - the probability of whether we should add edge or not goes to GraphBuilder. So both classes are much easier to read and understand. Your Graph is harder to read because you made it very specific i.e. dependent on details of this specific simulation. I believe you are aware of Single Responsibility Principle - https://en.wikipedia.org/wiki/Single_responsibility_principle - it is great concept which might provide you with rational for having small focused classes doing one job well.

2) You pass source vertex as argument to Graph constructor. My Graph's constructor only accepts number of vertexes. I pass 'source' vertex to the calculate method: like calculateShortestPath(int source, int destination) method so that I can calculate shortest path for different pairs of <source, destination> on *the same graph*. Also it would be easier to follow details about source vs destination in code since both could be a part of calculateShortestPath method.

3) You didn't implement PriorityQueue so your n^2 two loops: for (vertices) { for (vertices) {} } are less efficient than the implementation with PriorityQueue backed by minHeap as recommended by the task description. See some examples at Quora: https://www.quora.com/What-is-the-most-simple-efficient-C++-code-for-Dijkstras-shortest-path-algorithm.

4) There are typos in your code and comments. Given the obvious effort you did put into this task they seem a bit outstanding.

5) I use TDD approach to implement my homework tasks: tests are great additional way of proving that your code actually works. Here is example of test from my homework:

#include "Graph.h"

#include <cassert>

void test_calculateShortestPathDistance_threeElements() {
    Graph graph(3);

    graph.addEdge(0, 1, 11);
    graph.addEdge(1, 2, 22);
    graph.addEdge(0, 2, 5);

    DijkstraAlgorithm algorithm(graph);

    int shortestPathDistance = algorithm.calculateShortestPathDistance(0, 2);

    assert(shortestPathDistance == 5);
}

If shortestPathDistance is not 5 this test will fail clearly showing you the source line. For this homework I have around 20-30 tests: Graph, PriorityQueue, DijkstraAlgorithm, GraphBuilder - all these classes are covered with basic tests.

I highly encourage you to adopt this approach.

6) It is not possible to open your Visual Studio project on OS X machine. I use Xcode IDE for my homework but when I submit it to Coursera I create Makefile to build and run my homework that I consider more universal and portable way across different platforms. Again this is merely an advice, not critics.

Otherwise, great work! I'll subtract one point for efficiency. All other aspects are really good (especially your description of what you learned and your comments throughout the code).

Stanislav


